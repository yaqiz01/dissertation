#!env/bin/python

import numpy as np
import matplotlib
matplotlib.use('agg')
import matplotlib.pyplot as plt
import pandas as pd
from cycler import cycler
from scipy import stats

def savefig(fig, plot_path, **kws):
    if 'size' in kws:
        w,h, = kws['size']
        fig.set_size_inches(w,h)
    print("Generate {}".format(plot_path))
    plt.savefig(plot_path, format='pdf', dpi=900)

def plot_mlp():
    tab = pd.read_csv(
        'data/191119_145543_0800_Tst_sim_ef6cf6af_10f10351_4132476.csv',
        header=0, # row for header file
        encoding="utf-8-sig",
    )
    print(tab[['VPCU','VPMU']])
    pcu = tab.VPCU
    pmu = tab.VPMU
    ops = tab['param'].apply(lambda x: int(x.split('ops=List(')[1].split(",")[0]))
    fig, ax = plt.subplots()
    ax2 = ax.twinx()

    bar_width = 0.15
    opacity = 0.8
    index = np.arange(len(ops))

    colors = ['#003f5c', '#bc5090', '#ffa600']

    ax.bar(index, pcu, bar_width,
    alpha=opacity,
    color=colors[0],
    label='PCU')

    ax.bar(index, pmu, bar_width, bottom=pcu,
    alpha=opacity,
    color=colors[1],
    label='PMU')

    thrpt = 1.0 / (4 / ops)
    ax2.plot(index, thrpt,
    color=colors[2],
    label='Throughput',
    marker='d',
    )
    fig.legend(loc='upper left', bbox_to_anchor=(0.2,0.88))

    ax.set_xticks(index)
    ax.set_xticklabels(ops)
    ax.set_xlabel("Output Channel Parallelization")
    ax.set_ylabel("Number of CU")
    ax2.set_ylabel("Throughput (Gsample/s)",rotation=-90, labelpad=20)
    fig.subplots_adjust(left=0.2,right=0.8,bottom=0.2)
    savefig(fig, 'figs/mlp.pdf', size=(4,4))

def plot_gpu_slide():
    tab = pd.read_csv(
        'data/gpu_comp.csv',
        header=0, # row for header file
        encoding="utf-8-sig",
        sep=' *, *',
        engine='python',
    )
    def speedup(x):
        d = {}
        for met in ['Throughput','Latency']:
            sara = x[x.Compiler=='SARA'][met].values[0]
            gpu = x[x.Compiler!='SARA'][met].values[0]
            if met=='Throughput':
                d[met] = sara / gpu
                if x['Benchmark'].values[0] in ['LSTM (batch-32)','SqueezeNet (batch-1)']:
                    d['Norm'+met] = d[met] * 9
                else:
                    d['Norm'+met] = d[met]
            else:
                d[met] = gpu / sara
        return pd.Series(d)
    tab = tab.groupby('Benchmark').apply(speedup)
    tab = tab.sort_values('NormThroughput')
    tab = tab.reset_index()

    d = {}
    d['Benchmark'] = "Geo-Mean"
    for met in ['Throughput','Latency','NormThroughput']:
        d[met] = stats.gmean(tab[met].values)
    d = pd.Series(d)
    print(d)
    tab = tab.append(d,ignore_index=True)

    print(tab)
    apps = tab['Benchmark'].values

    fig, ax = plt.subplots()

    bar_width = 0.15
    opacity = 0.8
    index = np.arange(len(apps))

    colors = ['#003f5c', '#bc5090', '#ffa600']
    ax.set_prop_cycle(cycler(color=colors))

    ax.bar(index, tab['Latency'], bar_width,
    alpha=opacity,
    label='Latency')
    index = index + bar_width

    ax.bar(index, tab['NormThroughput'], bar_width,
    alpha=opacity,
    label='Throughput (Normalized to Resource)')
    ax.bar(index, tab['Throughput'], bar_width,
    alpha=opacity,
    label='Throughput')

    maxx = max(index)+0.3
    ax.plot([-0.2,maxx],[1,1],color='k',linestyle='--')
    ax.fill_between([len(index)-1.3,maxx], [0,0], [50,50], color='#e5e5e5')
    ax.set_ylim(0,1.1*max(tab['NormThroughput']))
    ax.set_xlim(-0.2,maxx)
    apps = [app.replace("(",'\n(') for app in apps]
    ax.set_xticks(index-bar_width/2)
    ax.set_xticklabels(apps,rotation=30)
    ax.set_ylabel("Improvement over V100")
    ax.legend()

    fig.subplots_adjust(bottom=0.2)
    fig.set_size_inches(7,3.5)
    plot_path = 'figs/slide_gpu.pdf'
    print("Generate {}".format(plot_path))
    plt.savefig(plot_path, format='pdf', dpi=900)

def main():

    plot_mlp()
    plot_gpu_slide()

main()

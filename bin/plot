#!env/bin/python

import numpy as np
import matplotlib
matplotlib.use('agg')
import matplotlib.pyplot as plt
import pandas as pd
from cycler import cycler
from scipy import stats
import pydotplus as pydot

def savefig(fig, plot_path, **kws):
    if 'size' in kws:
        w,h, = kws['size']
        fig.set_size_inches(w,h)
    print("Generate {}".format(plot_path))
    plt.savefig(plot_path, format='pdf', dpi=900)

def plot_mlp():
    tab = pd.read_csv(
        'data/191119_145543_0800_Tst_sim_ef6cf6af_10f10351_4132476.csv',
        header=0, # row for header file
        encoding="utf-8-sig",
    )
    print(tab[['VPCU','VPMU']])
    pcu = tab.VPCU
    pmu = tab.VPMU
    ops = tab['param'].apply(lambda x: int(x.split('ops=List(')[1].split(",")[0]))
    fig, ax = plt.subplots()
    ax2 = ax.twinx()

    bar_width = 0.15
    opacity = 0.8
    index = np.arange(len(ops))

    colors = ['#003f5c', '#bc5090', '#ffa600']

    ax.bar(index, pcu, bar_width,
    alpha=opacity,
    color=colors[0],
    label='PCU')

    ax.bar(index, pmu, bar_width, bottom=pcu,
    alpha=opacity,
    color=colors[1],
    label='PMU')

    thrpt = 1.0 / (4 / ops)
    ax2.plot(index, thrpt,
    color=colors[2],
    label='Throughput',
    marker='d',
    )
    fig.legend(loc='upper left', bbox_to_anchor=(0.2,0.88))

    ax.set_xticks(index)
    ax.set_xticklabels(ops)
    ax.set_xlabel("Output Channel Parallelization")
    ax.set_ylabel("Number of VU")
    ax2.set_ylabel("Throughput (Gsample/s)",rotation=-90, labelpad=20)
    fig.subplots_adjust(left=0.2,right=0.8,bottom=0.2)
    savefig(fig, 'figs/mlp.pdf', size=(4,4))

def plot_gpu_slide():
    tab = pd.read_csv(
        'data/gpu_comp.csv',
        header=0, # row for header file
        encoding="utf-8-sig",
        sep=' *, *',
        engine='python',
    )
    def speedup(x):
        d = {}
        for met in ['Throughput','Latency']:
            sara = x[x.Compiler=='SARA'][met].values[0]
            gpu = x[x.Compiler!='SARA'][met].values[0]
            if met=='Throughput':
                d[met] = sara / gpu
                if x['Benchmark'].values[0] in ['LSTM (batch-32)','SqueezeNet (batch-1)']:
                    d['Norm'+met] = d[met] * 9
                else:
                    d['Norm'+met] = d[met]
            else:
                d[met] = gpu / sara
        return pd.Series(d)
    tab = tab.groupby('Benchmark').apply(speedup)
    tab = tab.sort_values('NormThroughput')
    tab = tab.reset_index()

    d = {}
    d['Benchmark'] = "Geo-Mean"
    for met in ['Throughput','Latency','NormThroughput']:
        d[met] = stats.gmean(tab[met].values)
    d = pd.Series(d)
    print(d)
    tab = tab.append(d,ignore_index=True)

    print(tab)
    apps = tab['Benchmark'].values

    fig, ax = plt.subplots()

    bar_width = 0.15
    opacity = 0.8
    index = np.arange(len(apps))

    colors = ['#003f5c', '#bc5090', '#ffa600']
    ax.set_prop_cycle(cycler(color=colors))

    ax.bar(index, tab['Latency'], bar_width,
    alpha=opacity,
    label='Latency')
    index = index + bar_width

    ax.bar(index, tab['NormThroughput'], bar_width,
    alpha=opacity,
    label='Throughput (Normalized to Resource)')
    ax.bar(index, tab['Throughput'], bar_width,
    alpha=opacity,
    label='Throughput')

    maxx = max(index)+0.3
    ax.plot([-0.2,maxx],[1,1],color='k',linestyle='--')
    ax.fill_between([len(index)-1.3,maxx], [0,0], [50,50], color='#e5e5e5')
    ax.set_ylim(0,1.1*max(tab['NormThroughput']))
    ax.set_xlim(-0.2,maxx)
    apps = [app.replace("(",'\n(') for app in apps]
    ax.set_xticks(index-bar_width/2)
    ax.set_xticklabels(apps,rotation=30)
    ax.set_ylabel("Improvement over V100")
    ax.legend()

    fig.subplots_adjust(bottom=0.2)
    fig.set_size_inches(7,3.5)
    plot_path = 'figs/slide_gpu.pdf'
    print("Generate {}".format(plot_path))
    plt.savefig(plot_path, format='pdf', dpi=900)


class Graph():
    def __init__(self, *args, **kws):
        self.args = args
        self.kws = kws
    def __enter__(self):
        self.graph = pydot.Dot(graph_type="digraph")
        return self
    def __exit__(self, type, value, traceback):
        self.graph.write_pdf(*self.args, **self.kws)

    def node(self, name, **kws):
        attr = kws.copy()
        if "pos" in attr:
            x,y = attr["pos"]
            scale = 1.5
            x = x * scale
            y = y * scale
            attr["pos"] = "{},{}!".format(x,y)
        n  = pydot.Node(name, **attr)
        self.graph.add_node(n)
        return n
    
    def edge(self, src, dst, **kws):
        e = pydot.Edge(src, dst, **kws)
        self.graph.add_edge(e)
        return e

class DGraph(Graph):
    def __init__(self, *args, **kws):
        super().__init__(*args, **kws)
        self.pos = 0
    def vnode(self, name, **kws):
        n = self.node(name, pos="0,{}!".format(self.pos), **kws)
        self.pos += 1.5
        return n

    def bedge(self, src, dst, **kws):
        return self.edge(src,dst,style="dashed",**kws)

def plot_dep():
    nodeattr = {}
    nodeattr['shape']="circle"
    nodeattr['penwidth']=2
    nodeattr['fillcolor']="white"
    nodeattr['style']="filled"
    nodeattr['fontcolor']="black"
    nodeattr['fontname']="DejaVu Sans"
    edgeattr = {}
    edgeattr['penwidth'] = 2
    edgeattr['arrowhead'] = "vee"

    with DGraph('figs/dep.pdf') as G:
        W1 = G.node("W1", **nodeattr)
        R1 = G.node("R1", **nodeattr)

        G.edge(W1,R1,**edgeattr)
        G.bedge(R1,W1,**edgeattr)

    with DGraph('figs/dep1.pdf') as G:
        W0 = G.node("W0", **nodeattr)
        R0 = G.node("R0", **nodeattr)
        W1 = G.node("W1", **nodeattr)
        R1 = G.node("R1", **nodeattr)

        G.edge(W0,R0,**edgeattr)
        G.bedge(R0,W0,**edgeattr)
        G.edge(W1,R1,**edgeattr)
        G.bedge(R1,W1,**edgeattr)

    with DGraph('figs/dep2.pdf', prog='neato') as G:
        W0 = G.node("W0", pos=(0,1), **nodeattr)
        R0 = G.node("R0", pos=(0,0), **nodeattr)
        W1 = G.node("W1", pos=(1,1), **nodeattr)
        R1 = G.node("R1", pos=(1,0), **nodeattr)

        G.edge(W0,R0,**edgeattr)
        G.bedge(R0,W0,**edgeattr)
        G.edge(W1,R0,**edgeattr)
        G.bedge(R0,W1,**edgeattr)
        G.edge(W1,R1,**edgeattr)
        G.bedge(R1,W1,**edgeattr)
        G.edge(W0,R1,**edgeattr)
        G.bedge(R1,W0,**edgeattr)

    with DGraph('figs/dep3.pdf') as G:
        W1 = G.node("W1", **nodeattr)
        W2 = G.node("W2", **nodeattr)
        R1 = G.node("R1", **nodeattr)

        G.edge(W1,W2,**edgeattr)
        G.edge(W1,R1,**edgeattr)
        G.bedge(W2,W1,**edgeattr)
        G.bedge(R1,W1,**edgeattr)

def main():

    plot_mlp()
    # plot_gpu_slide()
    # plot_dep()

main()
